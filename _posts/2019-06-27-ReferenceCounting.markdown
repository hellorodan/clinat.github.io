---
layout:     post
title:      "引用计数算法"
subtitle:   " \"Reference Counting\""
date:       2019-06-27 18:20:00
author:     "Clinat"
header-img: "img/post-bg-astronaut.jpg"
catalog: true
tags:
    - GC
---

> “”


## 引用计数算法

该算法是在对象头中记录引用该对象的数量，称为应用计数器，当创建对象或者更新指针时都会相应的改变对象的引用计数器。当对象的引用计数器位0时，便会删除该对象同时将该内存块添加到空闲链表中。

<img src="/img_post/ReferenceCounting/reference_counting0.png" style="zoom:50%">

**优点：**引用计数法的最大的特点就是可以即时的回收对象，因为当程序修改对象的引用时，会判断该对象的引用计数器是否变为0，如果位0会立即释放该对象。同时，因为更新引用产生垃圾时，都会立即释放垃圾，也就缩短了程序的最大暂停时间。该方法对引用计数器进行更新时，不需要从root进行查找，这一点与标记-清除算法不同。

**缺点：**引用计数法也存在许多问题，由于程序会频繁的更新对象的引用，所以会导致频繁的更新引用计数器的值；为每个对象设置引用计数器会导致引用计数器占用了大量的内存空间；同时该算法是在程序执行的过程中完成对对象的内存管理，所以实现起来非常复杂，需要修改非常多常用操作，例如更新指针的操作。此外，最重要的一点是，该算法不能释放具有循环引用的对象。



## 延迟引用计数法

因为程序在执行的过程中，修改最频繁的便是根引用，所以延迟引用计数法的做法是先不统计由根引用导致的引用计数器的增量，而是将当前引用计数器为0的对象添加到ZCT(Zero Count Table)中，该表中记录的是引用计数器为0的对象，但并不代表该对象为可释放的对象，因为没有统计根引用。

<img src="/img_post/ReferenceCounting/reference_counting1.png" style="zoom:50%">

在删除对象的引用的同时，会判断引用数量是否为0，如果引用计数器的值为0，则将该对象添加到ZCT中，当创建对象申请空间时，如果空闲空间不足，则扫描ZCT，判断该表中的对象是否可以释放，如果可以释放则将该对象释放，扫面完ZCT之后在分配申请的空间。

其中，在判断ZCT中的对象是否可以释放的方法是，扫面所有的root，并更新这些root所指向的对象的引用计数器，之后在判断各个对象的引用计数器是否为0，如果为0则释放该对象。之后再将root引用的对象的引用计数器减一。

**优点：**该方法的主要目的就是最后释放对象的时候再统计root引用，减少root引用的频繁更新带来的引用计数器的频发更新。

**缺点：**由于采用了延迟引用计数的方式，所以垃圾不能及时的回收，会导致垃圾堆积，这也就丧失了引用计数算法的优点——垃圾的即时回收。



## Sticky 引用计数法

Sticky 引用计数法的主要目的就是解决引用计数器本身所占的内存开销过大的问题。通常情况下，为每个对象分配一个字大小的引用计数器会占用非常大的内存空间。所以该方法采用的是使用5位来作为引用计数器，所以5位的引用计数器只能记录2的5次方减1的引用。

但是，如果引用数量超过了这个范围就会导致计数器溢出，这时，Sticky 引用计数法采用的方法便是对引用计数器移除的对象不做任何操作，或者配合GC标记-清除算法对内存进行管理。

因为，通常情况下下，一个对象的引用数量不会很大，如果一个对象的引用数量超过了这个范围，则说明该对象一定是非常重要的，所以我们可以不对它进行操作。而配合GC标记-清除算法的方式是在适当的时机调用GC标记-清除算法，该标记-清除算法和传统的算法有一定的不同，该算法在执行之前需要清空所有对象的引用计数器，然后将所有所有root引用的对象添加到标记栈中，之后遍历该标记栈，增加标记栈中对象的引用计数器的值，然后将该对象引用的对象添加到该标记栈中。统计完所有的对象之后，遍历堆中所有的对象，并释放掉引用计数器为0的对象。

<img src="/img_post/ReferenceCounting/reference_counting2.png" style="zoom:50%">

该方法由于没有采用传统的标记而是使用引用计数器，所以需要多次遍历活跃对象，所以降低了该算法的吞吐量。但是优点是该算法能够释放调具有循环引用的对象。



## 1 位引用计数法

该方法是Sticky 引用计数法的一个极端的例子，只采用1位来表示引用数量，并且这1位不是放在对象头中，而是由指针来持有。当指针的该位为0时，表示指针所指的对象只有当前指针这一个引用，即 UNIQUE 状态，所以当删除该指针时可以释放调该对象。当有其他指针也指向该对象时，指针的计数位为1，表示有两个或以上的指针指向该对象，即 MULTIPLE 状态。

<img src="/img_post/ReferenceCounting/reference_counting3.png" style="zoom:50%">

**优点：**传统的算法使用引用计数器，并且引用计数器保存在对象头中，对引用计数器进行更新时需要读取对象，这时便容易造成高速缓存缺失，增加读取时间。而采用1位引用记数法时，不需要读取被引用的对象，所以能够减少高速缓存缺失的概率。

**缺点：**该方法的缺点和Sticky 引用计数法类似，即如何保证引用计数器溢出的对象的回收。



## 部分标记-清除算法

部分标记-清除算法只扫描有可能为具有循环引用的垃圾。该算法使用四种颜色表示各个对象的不同状态，如下图：

<img src="/img_post/ReferenceCounting/reference_counting4.png" style="zoom:50%">

首先，在创建对象时，其初始的颜色为BLACK。

<img src="/img_post/ReferenceCounting/reference_counting5.png" style="zoom:50%">

当删除对象引用时，会先判断该对象的引用计数器是否为0，如果为0则直接释放该对象，如果不为0，则将该对象添加到hatch_queue中，并标记为 HATCH 状态。

<img src="/img_post/ReferenceCounting/reference_counting6.png" style="zoom:50%">

当创建新对象，首先尝试创建该对象，如果创建失败，则遍历hatch_queue中的所有的对象，并将该对象标为GRAY，之后遍历该对象所以引用的所有对象，并将这些对象的引用计数器减一，同时标为GRAY状态。

<img src="/img_post/ReferenceCounting/reference_counting7.png" style="zoom:50%">

之后扫描该标为GRAY的对象，判断如果该对象的引用计数器的值大于0，则将该对象标为BLACK，如果为0，则标为WHITE。

<img src="/img_post/ReferenceCounting/reference_counting8.png" style="zoom:50%">

最后，扫描该对象，释放该对象以及该对象所引用的对象中标为WHITE的对象。

<img src="/img_post/ReferenceCounting/reference_counting9.png" style="zoom:50%">

当扫描完hatch_queue之后，再进行空间分配，如果此时创建对象失败，则表示没有可用空间分配给该对象。

该算法的优点是能够回收具有循环引用的对象。但是该算法还有一定的局限性，该算法会扫描对象三次，大大增加了内存管理所花费的时间。